---
layout: post
category: DDIA
---

## TOC

一个数据库在最基础的层次上需要完成两件事情：当你把数据交给数据库时，它应当把数据存储起来；而后当你向数据库要数据时，它应当把数据返回给你。

## 驱动数据库的数据结构

### 最简单的数据库

```
#!/bin/bash
db_set () {
echo "$1,$2" >> database
}
db_get () {
grep "^$1," database | sed -e "s/^$1,//" | tail -n 1
}
```

使用的时候

```
$ db_set 123456 '{"name":"London","attractions":["Big Ben","London Eye"]}' 

$ db_set 42 '{"name":"San Francisco","attractions":["Golden Gate Bridge"]}'

$ db_get 42
{"name":"San Francisco","attractions":["Golden Gate Bridge"]}

$ db_set 42 '{"name":"San Francisco","attractions":["Exploratorium"]}'

$ db_get 42{"name":"San Francisco","attractions":["Exploratorium"]}

$ cat database123456,{"name":"London","attractions":["Big Ben","London Eye"]}42,{"name":"San Francisco","attractions":["Golden Gate Bridge"]}42,{"name":"San Francisco","attractions":["Exploratorium"]}
```

底层的存储：一个文本文件，每行包含一条逗号分隔的键值对，每次调用set函数就会追加记录，旧的记录不会被覆盖，所以查找最新值时候，需要找文件中键最后出现的位置。

优点：在极其简单的场景有很好的性能，因为在文件尾部追加写入很高效。
缺点：当数据库中有大量记录时，查找性能会很差，因为要从头到尾扫描。查找的开销是O(n)。

所以我们需要**索引**。

索引是附加结构，只影响查询性能，维护额外的结构会产生开销，特别在写入时，因为追加是最简单的写入操作。任何类型的索引通常都会减慢写入速度，因为每次写入数据都需要更新索引。

所以这里是一个trade off，数据库不会默认索引所有内容，需要DBA通过查询模式来手动选择索引，从而达到最大收益又不会引入超出必要的开销。

### 哈希索引

之前在各种编程语言中已经接触过哈希映射。*既然我们已经有内存中数据结构hashmap，为什么不使用它来索引在磁盘上的数据呢？*

假设我们的数据存储只是一个追加写入的文件，最简单的想法就是在内存中保存一个hashmap，每个键值映射到数据文件中的字节偏移量。（所有键必须能放入到可用内存中）

像这种方式适合每个键经常更新的情况。例如key可能是视频的url，value是它播放的次数（每次有人点击播放按钮时递增）。这种工作负载中，有很多写操作，但是没有太多不同的键，也就是说每个键都有很多写操作，并且将所有键保存在内存中是可行的。

*追加写入文件如何避免用完磁盘空间呢？*

将日志分为特定大小的段，当日志增长到特定尺寸时关闭当前段文件，开始写入一个新的段文件，然后对这些段进行压缩（compaction）。压缩是在日志中丢弃重复的键，保留键的最近更新。

![](https://jeremy0953.github.io/pics/2021-10-24-pic1.png)
