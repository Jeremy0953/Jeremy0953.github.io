<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-10-17T23:13:22+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">This is Jeremy!</title><subtitle>Carpe Diem
</subtitle><author><name>Jeremy Yang</name></author><entry><title type="html">数据模型与查询语言</title><link href="http://localhost:4000/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80.html" rel="alternate" type="text/html" title="数据模型与查询语言" /><published>2021-10-17T00:00:00+08:00</published><updated>2021-10-17T00:00:00+08:00</updated><id>http://localhost:4000/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80</id><content type="html" xml:base="http://localhost:4000/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80.html">&lt;h2 id=&quot;toc&quot;&gt;TOC&lt;/h2&gt;

&lt;p&gt;对于每层数据模型的关键问题是：&lt;strong&gt;它是如何用低一层数据模型来表示的？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一个复杂的应用程序可能会有更多的中间层次，比如基于API的API，不过基本思想仍然是一样的：每个层都通过提供一个明确的数据模型来隐藏更低层次中的复杂性。&lt;/p&gt;

&lt;h2 id=&quot;关系模型与文档模型&quot;&gt;关系模型与文档模型&lt;/h2&gt;

&lt;p&gt;现在最著名的数据模型可能是SQL，他基于Edgar Codd在1970年提出的关系模型：数据被组织成关系（SQL中称作表），其中每个关系是元组（SQL中称作行）的无序集合。&lt;/p&gt;

&lt;h3 id=&quot;nosql的诞生&quot;&gt;NoSQL的诞生&lt;/h3&gt;

&lt;p&gt;NoSQL被解释为（Not Only SQL），NoSQL数据库背后的驱动因素&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;需要比关系型数据库更良好的扩展性，包括更大的数据集和非常高的写入吞吐量&lt;/li&gt;
  &lt;li&gt;免费开源&lt;/li&gt;
  &lt;li&gt;关系模型不能很好地支持一些特殊的查询操作&lt;/li&gt;
  &lt;li&gt;受限于关系模型的限制性，渴望一种更具多动态性于表现力的数据模型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;不同的应用程序有不同的需求，一个用例的最佳技术选择可能不同于另一个用例的最佳技术选择，因此在可见的未来，关系数据库似乎可能与各种非关系数据库一起使用，这种想法有时被称为&lt;em&gt;混合持久化&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;对象关系不匹配&quot;&gt;对象关系不匹配&lt;/h3&gt;

&lt;p&gt;目前大多数应用开发程序都使用面向对象的语言来开发，如果数据存储在关系表中，则需要一个笨拙的转换层。模型之间的不连贯有时被称为&lt;em&gt;阻抗不匹配&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;像ActiveRecord和Hibernate这样的&lt;em&gt;对象关系映射（object-relational mapping, ORM）&lt;/em&gt;框架可以减少这个转换层所需的样板代码的数量，但是它们不能完全隐藏这两个模型之间的差异。&lt;/p&gt;

&lt;p&gt;例如一个领英上面的简历的例子：&lt;/p&gt;

&lt;p&gt;如果用关系型数据模型去表征的话：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Jeremy0953/Jeremy0953.github.io/main/pics/2021-10-17-pic1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用JSON文档去表示：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
&quot;user_id&quot;: 251,
&quot;first_name&quot;: &quot;Bill&quot;,
&quot;last_name&quot;: &quot;Gates&quot;,
&quot;summary&quot;: &quot;Co-chair of the Bill &amp;amp; Melinda Gates... Active blogger.&quot;,
&quot;region_id&quot;: &quot;us:91&quot;,
&quot;industry_id&quot;: 131,
&quot;photo_url&quot;: &quot;/p/7/000/253/05b/308dd6e.jpg&quot;,
&quot;positions&quot;: [
{
&quot;job_title&quot;: &quot;Co-chair&quot;,
&quot;organization&quot;: &quot;Bill &amp;amp; Melinda Gates Foundation&quot;
},
{
&quot;job_title&quot;: &quot;Co-founder, Chairman&quot;,
&quot;organization&quot;: &quot;Microsoft&quot;
}
],
&quot;education&quot;: [
{
&quot;school_name&quot;: &quot;Harvard University&quot;,
&quot;start&quot;: 1973,
&quot;end&quot;: 1975
},
{
&quot;school_name&quot;: &quot;Lakeside School, Seattle&quot;,
&quot;start&quot;: null,
&quot;end&quot;: null
}
],
&quot;contact_info&quot;: {
&quot;blog&quot;: &quot;http://thegatesnotes.com&quot;,
&quot;twitter&quot;: &quot;http://twitter.com/BillGates&quot;
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;JSON表示比关系模型中的多表模式具有更好的局部性，如果在关系型数据库中获取简介信息则需要多表连接，在JSON表示中，所有相关的信息都在一个地方，一个查询就足够了。&lt;/p&gt;

&lt;h3 id=&quot;多对一和多对多的关系&quot;&gt;多对一和多对多的关系&lt;/h3&gt;

&lt;p&gt;解释一下为什么数据库中存的都是ID而不是纯字符串的名字&lt;/p&gt;

&lt;p&gt;如果用户用一个自由文本字段输入区域和行业，那么将他们存储为纯文本字符串是合理的。另一种方式是给出一个区域和行业的列表，让用户从下拉列表中进行选择。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;各个简介之间样式和拼写统一&lt;/li&gt;
  &lt;li&gt;避免歧义&lt;/li&gt;
  &lt;li&gt;易于更新——名称只存在一个地方，如需要修改则很容易进行全面更新。&lt;/li&gt;
  &lt;li&gt;本地化支持——当网站翻译成其他语言时，标准化的列表可以本地化&lt;/li&gt;
  &lt;li&gt;更好的搜索——比如搜索某某地的简历就可以匹配到这个简历（某某地的地名不一定显示出现）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;存储ID还是文本字符串，这是个副本（duplication）问题，当使用ID时，对人类有意义的信息（比如地名）只存储在一处，所有引用它的地方使用ID，当直接存储文本时，对人类有意义的信息就会复制在没处使用记录中。&lt;/p&gt;

&lt;p&gt;使用ID的好处是，ID对人们没有意义，所以也就永远不需要改变。任何对人类有意义的信息都有可能在未来的某个时刻被改变，如果这个信息被复制了多份，所有的副本都需要被更新，这会导致写入开销，也存在不一致的风险（一些副本更新了，一些还没更新）。去除此类重复是数据库规范化（normalization）的关键思想。&lt;/p&gt;

&lt;p&gt;文档模型对于连接的支持很弱。&lt;/p&gt;

&lt;p&gt;一对多的关系：比如简历中一个人的工作经历可能有，公司1，公司2，公司3，这样子是一对多的关系，对于这样的关系模式，文档模型可以很好地去描述。&lt;/p&gt;

&lt;p&gt;多对多的关系：比如简历中的工作经历中的公司1不仅是一个公司的名字而是一个指向公司实体的链接，同理其他的也是，那么这个就是一个多对多的关系，文档模型对于处理这样的多对多的关系比较乏力。&lt;/p&gt;

&lt;p&gt;比如在引用其他公司的时候需要利用到连接操作，但是文档对于连接的支持很弱，或者有些就直接不支持连接，只能在应用程序代码中执行多个查询来模拟连接。&lt;/p&gt;

&lt;h3 id=&quot;文档数据库是否是重蹈覆辙&quot;&gt;文档数据库是否是重蹈覆辙？&lt;/h3&gt;

&lt;p&gt;数据库最开始是一种很简单的数据模型，称为层次模型（hierarchical model），他将所有数据表示为嵌套在记录中的记录树，也是良好地处理一对多的关系但是很难应对多对多的关系，且不支持连接。&lt;/p&gt;

&lt;p&gt;后来人们提出了一些解决方案来解决层次模型的局限性，最突出的两个一个是关系模型，一个是网络模型。&lt;/p&gt;

&lt;h3 id=&quot;网络模型&quot;&gt;网络模型&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;CODASYL模型&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在层次模型的树结构中，每条记录只有一个父节点，在网络模型中，每个记录可能有多个父节点，网络模型中记录之间的链接不是外键，而更像是编程语言中的指针。访问记录的唯一方法是跟随从根记录起沿这些链路所形成的路径。这被称为访问路径。&lt;/p&gt;

&lt;p&gt;最简单的访问类似与遍历链表一样的访问。但在多对多关系的情况下，可能有不同的路径到达相同的记录，网络模型的程序员必须跟踪这些不同的访问路径。&lt;/p&gt;

&lt;p&gt;网络模型的查询是利用遍历记录列和跟随路径表在数据库中的移动游标来执行的。如果记录有多个父结点，则应用程序代码必须跟踪所有的关系。&lt;/p&gt;

&lt;p&gt;尽管手动选择访问路径能够最有效地利用非常有限的硬件功能，但这使得查询和更新数据库的代码变得复杂不灵活。如果没有路径就会陷入困境，你可以改变访问路径但是要浏览手写大量数据库查询代码。&lt;/p&gt;

&lt;h3 id=&quot;关系模型&quot;&gt;关系模型&lt;/h3&gt;

&lt;p&gt;关系模型是将所有模型放在光天化日之下，一个关系是元组的集合，仅此而已。如果你想读取数据，没有迷宫似的嵌套结构，也没有复杂的访问路径。你可以选中任何符合条件的行，读取特定行或者所有行，或者可以插入新的行。&lt;/p&gt;

&lt;p&gt;关系数据库中，查询优化器会自动决定查询的哪个部分以哪个顺序执行，是自动生成的，不需要由程序员生成。&lt;/p&gt;

&lt;p&gt;如果想要用新的方式查询，可以添加新的索引。&lt;/p&gt;

&lt;h3 id=&quot;关系数据库与文档数据库的对比&quot;&gt;关系数据库与文档数据库的对比&lt;/h3&gt;

&lt;p&gt;多对一的关系（比如许多人生活在一个特性的地区，许多人在一个特定的行业工作）&lt;/p&gt;

&lt;p&gt;在表示多对一和多对多的关系时，关系数据库和文档数据库并没有根本的不同。在这两种情况下，相关项目都被一个唯一的标识符引用，这个标识符在关系模型中被称为外键，在文档模型中被称为文档引用。&lt;/p&gt;

&lt;p&gt;文档数据模型，主要是架构灵活性，因为局部性而拥有更好的性能，对于某些应用程序而言更接近与应用程序所使用的数据结构。关系模型则是为连接提供更好的支以及支持多对一和多对多的关系。&lt;/p&gt;

&lt;h3 id=&quot;哪种更方便写代码&quot;&gt;哪种更方便写代码？&lt;/h3&gt;

&lt;p&gt;如果应用程序中有类似文档的结构，比如一对多关系树，通常一次性加载整个树，那么使用文档模型是一个好主意。&lt;/p&gt;

&lt;p&gt;文档模型有局限性，比如不能直接引用文档中嵌套的项目，而是说“用户251的位置列表中的第二项”。&lt;/p&gt;

&lt;p&gt;如果应用程序不需要多对多关系就没什么问题，但是如果需要多对多的话就不太好了。可以通过规范化减少对连接的需求，也可以在应用程序中模拟连接，等等，但是在这种情况下文档模型会导致更复杂的应用程序代码和更差的性能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;很难说一般情况哪种数据模型让应用程序代码更简单，取决于数据项时间的关系种类。对于高度相联的数据使用文档模型是糟糕的，但是选用关系模型是可接受的，使用图数据模型是最自然的。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;文档模型的架构灵活性&quot;&gt;文档模型的架构灵活性&lt;/h3&gt;

&lt;p&gt;大多数文档数据库都不会强制文档中的数据采用何种模式。没有模式意味可以将任意的key和value添加到文档中，当读取的时候，客户端无法保证文档可能包含的字段。&lt;/p&gt;

&lt;p&gt;文档数据库采取读时模式。&lt;/p&gt;

&lt;p&gt;读时模式（schema-on-read）数据的结构是隐含的，只有在数据被读取的时候才被解释。&lt;/p&gt;

&lt;p&gt;写时模式（schema-on-write）传统的关系数据库方法中，模式明确，且数据库确保所有的数据符合其模式。&lt;/p&gt;

&lt;p&gt;当应用程序想要改变数据格式时这两种区别比较大。文档数据库中，只需要开始写入具有新字段的新文档，并在程序中使用代码处理旧文档，例如：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (user &amp;amp;&amp;amp; user.name &amp;amp;&amp;amp; !user.first_name) {
// Documents written before Dec 8, 2013 don't have first_name
user.first_name = user.name.split(&quot; &quot;)[0];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在写时模式中&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE users ADD COLUMN first_name text;UPDATE users SET first_name = split_part(name, ' ', 1); -- PostgreSQLUPDATE users SET first_name = substring_index(name, ' ', 1); -- MySQL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;模式变更的速度很慢并且需要停运。尽管绝大数关系数据库可以在几毫秒内执行ALTER TABLE 语句，但是MySQL是一个例外，他执行ALTER TABLE时会复制整个表，所以更改一个大型表可能会花几分钟甚至几个小时的停机。&lt;/p&gt;

&lt;p&gt;大型表运行UPDATE都会很慢，因为每一行都要改写。&lt;/p&gt;

&lt;p&gt;由于某种原因，集合中的项目并不具有相同的结构时，读时模式更具有优势。比如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在许多不同类型的对象，将每种类型的对象放在自己的表中是不现实的。&lt;/li&gt;
  &lt;li&gt;数据的结构由外部系统决定，你无法控制外部系统且它随时可能变化。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在上述情况下，模式的坏处大于好处，无模式文档是一个更加自然的数据模型。要是所有的记录都有相同的结构，那么模式是强制这种结构的有效机制。&lt;/p&gt;

&lt;h3 id=&quot;查询的数据局部性&quot;&gt;查询的数据局部性&lt;/h3&gt;

&lt;p&gt;文档通常以单个连续字符串形式进行存储。如果应用程序经常需要访问整个文档（例如渲染整个网页），那么存储局部性将带来性能优势，如果数据分割到各个表中则需要进行多个索引查找才能全部检索出来，这需要花费更多的时间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;局部性仅仅适用于同时需要文档绝大部分内容的情况。&lt;/strong&gt;数据库通常需要加载整个文档，如果只是访问很大的文档中的一小部分，这个是很浪费的。而且更新文档的时候需要整个重写，只有不改变文档大小的修改才可以容易地原地执行。所以通常建议保持相对小的文档并且避免增加文档大小的写入。这些性能限制大大减少了文档数据库的实用场景。&lt;/p&gt;

&lt;h3 id=&quot;文档和关系数据库的融合&quot;&gt;文档和关系数据库的融合&lt;/h3&gt;

&lt;p&gt;如果一个数据库能够处理类似文档的数据，并且能够对其执行关系查询，那么应用程序就可以使用最符合其需求的功能组合。&lt;/p&gt;

&lt;p&gt;关系模型和文档模型的混合是未来数据库的一条很好的路线。&lt;/p&gt;

&lt;h2 id=&quot;数据查询语言&quot;&gt;数据查询语言&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;命令式语言&lt;/strong&gt;告诉计算机以特定顺序执行某些操作，比如java语言，循环遍历之类的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;声明式语言&lt;/strong&gt;如SQL或关系代数，你只需指定所需数据的模式，结果必须符合哪些条件，以及如何将数据转换。但是对于如何实现这个目标并没有要求，数据库的查询优化器去决定使用哪些索引哪些连接方法，以及什么顺序去执行。&lt;/p&gt;

&lt;p&gt;SQL示例不确保任何特定的顺序，因此不在意顺序是否改变。声明式语言往往适合并行执行。（命令代码由于指定了顺序，所以很难在多个机器和多个内核之间并行化，但是声明语言具有并行执行的潜力）&lt;/p&gt;

&lt;h3 id=&quot;web上的声明式查询&quot;&gt;Web上的声明式查询&lt;/h3&gt;

&lt;p&gt;利用CSS选择器要比Javascript的实现方式简洁多了。&lt;/p&gt;

&lt;h3 id=&quot;mapreduce查询&quot;&gt;MapReduce查询&lt;/h3&gt;

&lt;p&gt;MapReduce既不是一个声明式查询也不是一个完全命令式的查询，而是介于两者之间，查询的逻辑用代码片段表示，这些代码片段会被框架重复性调用。它基于map函数和reduce函数，两个函数存在于许多函数式编程语言中。&lt;/p&gt;

&lt;p&gt;map和reduce函数在功能上有所限制，他们必须是纯函数，他们只使用传递给他们的数据作为输入，不能执行额外的数据库查询也不能有任何副作用。这些限制允许数据库以任何顺序执行任何功能并在失败时重新运行他们。然而map和reduce函数仍然是强大的，他们可以解析字符串调用库函数执行计算等等。&lt;/p&gt;

&lt;p&gt;MapReduce是一个相当底层的编程模型，用于计算机集群上的分布式执行。&lt;/p&gt;

&lt;h2 id=&quot;图数据模型&quot;&gt;图数据模型&lt;/h2&gt;

&lt;p&gt;如果多对多的关系在你的数据中很常见，关系模型可以处理多对多关系的简单情况，但是随着数据之间的连接变得复杂，将数据建模成为图形显得更加自然。&lt;/p&gt;

&lt;p&gt;一个图由两种对象组成：顶点和边。&lt;/p&gt;

&lt;p&gt;多种数据可以被建模成为一个图形，比如社交图谱（顶点是人，边指示哪些人彼此认知）网络图谱（顶点是网页，边缘表示指向其他页面的HTML链接）等等。&lt;/p&gt;

&lt;p&gt;有几种不同但是相关的方法来构建和查询图表中的数据，比如属性图模型和三元组存储模型。&lt;/p&gt;

&lt;h3 id=&quot;属性图&quot;&gt;属性图&lt;/h3&gt;

&lt;p&gt;属性图模型中每个结点包括：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;唯一的标识符&lt;/li&gt;
  &lt;li&gt;一组出边&lt;/li&gt;
  &lt;li&gt;一组入边&lt;/li&gt;
  &lt;li&gt;一组属性（键值对）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个边包括：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;唯一标识符&lt;/li&gt;
  &lt;li&gt;边的起点/尾部顶点&lt;/li&gt;
  &lt;li&gt;边的终点/头部顶点&lt;/li&gt;
  &lt;li&gt;描述两个顶点之间关系类型的标签&lt;/li&gt;
  &lt;li&gt;一组属性(键值对)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以将图存储看做两个关系表组成，一个存储顶点另一个存储边。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;任何&lt;/strong&gt;顶点都可以有一条边连接到&lt;strong&gt;任何&lt;/strong&gt;其他顶点&lt;/li&gt;
  &lt;li&gt;给定任何顶点，可以高效找到入边和出边，从而遍历图。&lt;/li&gt;
  &lt;li&gt;通过不同类型的关系使用不同的标签，可以在一个图中存储几种不同的信息，同时仍然保持一个清晰的数据模型。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些特性为数据建模提供了很大的灵活性。以及具有可演化性。&lt;/p&gt;

&lt;p&gt;并且图数据库还有相应的声明式查询语言。查询优化程序会自动选择预测效率最高的策略。&lt;/p&gt;

&lt;p&gt;倒是也可以在SQL中表示图数据并且进行查询，只是很困难很麻烦罢了。&lt;/p&gt;

&lt;h3 id=&quot;三元组存储&quot;&gt;三元组存储&lt;/h3&gt;

&lt;p&gt;三元组存储模式大体上与属性图模型相同，用不同的词来描述相同的想法。&lt;/p&gt;

&lt;p&gt;三元组存储中，所有信息都以三部分表示形式存储（主语，谓语，宾语）比如（吉姆，喜欢，香蕉）&lt;/p&gt;

&lt;p&gt;三元组的主语相当于图中的一个顶点。而宾语是下面两者之一：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;原始数据类型中的值，利用字符串或数字。此时三元组的谓语和宾语相当于主语顶点上的属性的键和值。例如，(lucy,age,33)等价于顶点lucy,并且属性{“age”:33}.&lt;/li&gt;
  &lt;li&gt;图中的另一个顶点。在这种情况下，谓语是图中另一条边，主语是其尾部顶点，宾语是头部顶点。例如，在(lucy,marriedTo,alain)中主语和宾语lucy和alain都是顶点，并且谓语marriedTo是连接他们的边的标签。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;例子：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@prefix : &amp;lt;urn:example:&amp;gt;.
_:lucy a :Person.
_:lucy :name &quot;Lucy&quot;.
_:lucy :bornIn _:idaho.
_:idaho a :Location.
_:idaho :name &quot;Idaho&quot;.
_:idaho :type &quot;state&quot;.
_:idaho :within _:usa.
_:usa a :Location
_:usa :name &quot;United States&quot;
_:usa :type &quot;country&quot;.
_:usa :within _:namerica.
_:namerica a :Location
_:namerica :name &quot;North America&quot;
_:namerica :type :&quot;continent&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当谓语表示边时，该宾语是一个顶点。当谓语是一个属性时，该宾语是一个字符串。&lt;/p&gt;

&lt;h3 id=&quot;图数据库与网络模型的比较&quot;&gt;图数据库与网络模型的比较&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;在CODASYL中，数据库有一个模式，用于指定哪种记录类型可以嵌套在其他记录类型中，在图数据库中，不存在这样的限制，任何顶点都可以具有到其他任何顶点的边，这为应用程序适应不断变化的需求提供了更大的灵活性。&lt;/li&gt;
  &lt;li&gt;在CODASYL中，到达特定的记录的唯一方法是遍历一个访问路径，但是图数据库中可以用唯一ID直接引用任何顶点，也可以使用索引来查找具有特定值的顶点。&lt;/li&gt;
  &lt;li&gt;在CODASYL中，记录的后续是一个有序集合，所以数据库的人得维持排序，并且插入新记录的应用程序不得不担心新纪录在集合中的位置，在图形数据库中，顶点和边不是有序的（只能在查询时对结果进行排序）&lt;/li&gt;
  &lt;li&gt;在CODASYL中，所有查询都是命令式的难以编写，并且很容易因为架构中的变化而受到破坏。在图形数据库中，如果需要也可以用命令式代码，但是绝大数图数据库也支持高级声明式查询语言。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;文档数据库的应用场景是：数据通常是自我包含的，而且文档之间的关系非常稀少。&lt;/li&gt;
  &lt;li&gt;图形数据库应用与相反的场景：任意事物都可能与任何事物相关联。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;文档、关系和图形这三种模型在今天都被广泛应用且在&lt;strong&gt;各自的领域&lt;/strong&gt;发挥很好。一个模型也可以用另一个模型来模拟。例如可以用关系数据库模拟图数据，但是结果往往糟糕。这就是为什么我们有着不同目的的不同系统，而不是一个单一的万能解决方案。&lt;/p&gt;

&lt;p&gt;文档数据库和图数据库有一个共同点，通常不会为存储的数据强制一个模式，这可以使得应用程序容易适应不断变化的需求。但是应用程序可能仍然会假定数据具有一定的结构，这只是模式是明确的（写入时强制）还是隐含的（读取时处理）的问题。&lt;/p&gt;</content><author><name>Jeremy Yang</name></author><category term="DDIA" /><summary type="html">TOC</summary></entry><entry><title type="html">可靠性 可扩展性 可维护性</title><link href="http://localhost:4000/%E5%8F%AF%E9%9D%A0%E6%80%A7-%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7-%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7.html" rel="alternate" type="text/html" title="可靠性 可扩展性 可维护性" /><published>2021-10-08T00:00:00+08:00</published><updated>2021-10-08T00:00:00+08:00</updated><id>http://localhost:4000/%E5%8F%AF%E9%9D%A0%E6%80%A7-%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7-%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7</id><content type="html" xml:base="http://localhost:4000/%E5%8F%AF%E9%9D%A0%E6%80%A7-%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7-%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7.html">&lt;h2 id=&quot;toc&quot;&gt;TOC&lt;/h2&gt;

&lt;p&gt;现在很多应用都是数据密集型应用(data-intensive)，而不是计算密集型应用(compute-intensive)&lt;/p&gt;

&lt;p&gt;数据密集型应用的标准组件及其通用功能：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;存储数据（database）&lt;/li&gt;
  &lt;li&gt;加快读取速度(cache)&lt;/li&gt;
  &lt;li&gt;按关键词搜索数据，或对数据进行过滤(search indexes)&lt;/li&gt;
  &lt;li&gt;向其他进程发送消息，进行异步处理(stream processing)&lt;/li&gt;
  &lt;li&gt;定期处理大批量数据(batch processing)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基础目标：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;可靠性(Reliability)&lt;/li&gt;
  &lt;li&gt;可扩展性(Scalability)&lt;/li&gt;
  &lt;li&gt;可维护性(Maintainability)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;可靠性&quot;&gt;可靠性&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;系统在困境中仍可以正常工作&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;故障(fault)：造成错误的原因,通常定义为系统的一部分状态偏离其标准&lt;/p&gt;

&lt;p&gt;容错(fault-tolerant)：能&lt;strong&gt;预料&lt;/strong&gt;并应对故障的系统特性&lt;/p&gt;

&lt;p&gt;失效(failure): 系统作为一个整体停止向用户提供服务。&lt;/p&gt;

&lt;p&gt;硬件故障的解决方式：增加单个硬件的冗余度、软件容错机制&lt;/p&gt;

&lt;p&gt;软件错误：内部的系统性错误(systematic error)，比如失控进程占用共享资源等，还有比如级联故障等。解决方法：仔细考虑假设和交互，测试，进程隔离，测量监控等等……&lt;/p&gt;

&lt;p&gt;人为错误：运维配置错误是导致服务中断的首要原因。解决方法：以最小化犯错机会的方式设计系统（比如抽象、设计api等等），将人们最容易犯错的地方和可能导致失效的地方解耦(decouple)，提供一个功能齐全的非生产环境沙箱(sandbox)，在各个层次进行彻底的测试，允许从人为错误中简单快速地恢复，配置详细和明确的监控，良好的管理实践与充分的培训。&lt;/p&gt;

&lt;h2 id=&quot;可扩展性&quot;&gt;可扩展性&lt;/h2&gt;

&lt;p&gt;“如果系统以特定方式增长，有什么选项可以应对增长？”&lt;/p&gt;

&lt;p&gt;“如何增加计算资源来处理额外的负载？”&lt;/p&gt;

&lt;h3 id=&quot;描述负载&quot;&gt;描述负载&lt;/h3&gt;

&lt;p&gt;负载参数的最佳选择取决于系统架构，可能是每秒向web服务器发出的请求、数据库中的读写比率、聊天室中同时活跃的用户数量、缓存命中率或其他东西&lt;/p&gt;

&lt;h4 id=&quot;推特的例子&quot;&gt;推特的例子&lt;/h4&gt;

&lt;p&gt;推特发布推文：用户可以向其粉丝发布新消息（平均 4.6k请求/秒，峰值超过 12k请求/秒）。&lt;/p&gt;

&lt;p&gt;主页时间线：用户可以查阅他们关注的人发布的推文（300k请求/秒）。&lt;/p&gt;

&lt;p&gt;处理每秒12,000次写入（发推文的速率峰值）还是很简单的。然而推特的扩展性挑战并不是主要来自推特量，而是来自扇出（fan-out）——每个用户关注了很多人，也被很多人关注。&lt;/p&gt;

&lt;p&gt;有两种实现方式。&lt;/p&gt;

&lt;p&gt;方法1：&lt;/p&gt;

&lt;p&gt;发布推文时，只需要将新推文推入全局推文集合即可，当请求自己的主页时间线时，首先查找他关注的所有人，查询这些被关注用户发布的推文并按时间顺序合并。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Jeremy0953/Jeremy0953.github.io/main/pics/2021-10-08-pic1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以利用这样子的sql查询&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT tweets.*, users.*
FROM tweets
JOIN users ON tweets.sender_id = users.id
JOIN follows ON follows.followee_id = users.id
WHERE follows.follower_id = current_user
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;方法2：&lt;/p&gt;

&lt;p&gt;为每个用户的主页时间线维护一个缓存，当用户发布推文时就将新的推文插入到每一个关注者的缓存中。所以读取主页时间线的请求开销很小，因为已经提前计算好了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Jeremy0953/Jeremy0953.github.io/main/pics/2021-10-08-pic2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;推特一开始使用方法1，但是系统跟不上查询的负载，所以用了方法2&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;因为发推特的频率比查询主页的频率几乎低了两个数量级，所以这种情况下最好在写入时做更多的工作，在读取时做更少的工作&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;然而方法2的缺点是，发推特需要额外工作，尤其是对于一些粉丝众多的用户，发推特就会有大量的写入工作。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;所以在推特的例子中，每个用户粉丝数的分布（可能按照用户的发推频率来加权）是探讨可扩展性的一个关键负载参数，因为它决定了&lt;strong&gt;扇出负载&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;推特最终的解决方法：两种方法的混合，对于大多数用户采用方法2，对于少量具有海量粉丝的用户使用方法1，当用户读取主页时间线的时候，分别获取关注的明星的推文和自己的主页时间线缓存进行合并。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;妙啊&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;描述性能&quot;&gt;描述性能&lt;/h3&gt;

&lt;p&gt;“当增加负载参数并保持系统资源不变时，系统性能将受到什么影响？”&lt;/p&gt;

&lt;p&gt;“当增加负载参数并希望性能保持不变时，需要增加多少系统资源？”&lt;/p&gt;

&lt;p&gt;对于Hadoop这样的批处理系统，通常关心的是吞吐量(throughput)，即每秒可以处理的记录数量。对于在线系统，更重要的是响应时间(response time)，即客户端发送请求到接受响应之间的时间。&lt;/p&gt;

&lt;p&gt;延迟(lantency):某个请求等待处理的持续时长，在此期间处于休眠状态，并等待服务。&lt;/p&gt;

&lt;p&gt;响应时间(respense time):用户看到的，除了实际处理请求的时间，还包括网络延迟和排队延迟。&lt;/p&gt;

&lt;p&gt;我们需要把响应时间视为一个可以测量的数值分布，而不是单个数值。&lt;/p&gt;

&lt;p&gt;通常报表会展示平均响应时间(但是当你想知道典型响应时间，平均值不好)&lt;/p&gt;

&lt;p&gt;通常使用百分位点(percentiles)会更好，比如中位数就是p50，一半服务时间小于中位数，一半大于中位数，为了弄清楚异常值有多糟糕，可以看更高的百分位点比如p95,p99,p999(以为着95%,99%,99.9%的请求响应时间比该阈值快)&lt;/p&gt;

&lt;p&gt;响应时间的高百分位点（也叫做尾部延迟(tail latencies)）非常重要，因为它们直接影响用户服务体验，比如亚马逊描述内部响应时间用p999，即使只影响1000个中的1个，但是因为请求响应最慢的客户也是数据最多的客户，也可以说是最有价值的用户。&lt;/p&gt;

&lt;p&gt;排队延迟：由于服务器只能并行处理少量的事务(受CPU核数的限制)，所以有少量缓慢的请求就阻碍后续，称为头部阻塞(head-of-line blocking)。&lt;/p&gt;

&lt;p&gt;当负载参数增加时，如何保持良好的性能？&lt;/p&gt;

&lt;p&gt;纵向扩展(scaling up)(垂直扩展(vertical scaling)，转到更强大的机器)和横向扩展(scaling out)(水平扩展(horizontal scaling)，将负载分布到多台小机器上)&lt;/p&gt;

&lt;p&gt;跨多台机器部署无状态服务(stateless services)非常简单，但将带状态的数据系统从单节点变为分布式配置则可能引入许多额外复杂度。&lt;/p&gt;

&lt;p&gt;随着分布式系统的工具和抽象越来越好，可以预见分布式数据系统将成为未来的默认设置。&lt;/p&gt;

&lt;p&gt;大规模的系统架构通常是&lt;strong&gt;应用特定&lt;/strong&gt;的，&lt;strong&gt;没有可以一招鲜吃遍天的通用可扩展架构&lt;/strong&gt;，应用的问题可能是读取量、写入量、要存储的数据量、数据的复杂度、响应时间要求、访问模式或者所有问题的大杂烩。&lt;/p&gt;

&lt;p&gt;举个例子，，用于处理每秒十万个请求（每个大小为1 kB）的系统与用于处理每分钟3个请求（每个大小为2GB）的系统看上去会非常不一样，尽管两个系统有同样的数据吞吐量。&lt;/p&gt;

&lt;p&gt;一个良好适配应用的可扩展架构，是围绕着假设建立的，哪些操作是常见的？哪些操作是罕见的？这就是所谓负载参数。&lt;/p&gt;

&lt;h2 id=&quot;可维护性&quot;&gt;可维护性&lt;/h2&gt;

&lt;p&gt;可维护性又分为&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;可操作性(Operability)&lt;/li&gt;
  &lt;li&gt;简单性(Simplicity)&lt;/li&gt;
  &lt;li&gt;可演化性(evolability)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;可操作性&quot;&gt;可操作性&lt;/h3&gt;

&lt;p&gt;便于运维团队保持系统平稳运行&lt;/p&gt;

&lt;p&gt;比如通过良好的监控，提供对系统内部状态的可视性，提供良好的文档和易于理解的操作模型等等等等&lt;/p&gt;

&lt;h3 id=&quot;简单性管理复杂度&quot;&gt;简单性：管理复杂度&lt;/h3&gt;

&lt;p&gt;复杂度（complexity）有各种可能的症状，例如：状态空间激增、模块间紧密耦合、纠结的依赖关系、不一致的命名和术语、解决性能问题的Hack、需要绕开的特例等等&lt;/p&gt;

&lt;p&gt;消除额外复杂度的最好工具之一是&lt;strong&gt;抽象&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;比如SQL就是一种抽象，隐藏了复杂的磁盘/内存数据结构、来自其他客户端的并发请求、崩溃后的不一致性。&lt;/p&gt;

&lt;h3 id=&quot;可演化性拥抱变化&quot;&gt;可演化性：拥抱变化&lt;/h3&gt;

&lt;p&gt;敏捷工作模式，敏捷技术：如测试驱动开发(TDD,test-driven development)和重构(refactoring)&lt;/p&gt;

&lt;p&gt;修改数据系统并使其适应不断变化需求的容易程度，是与简单性和抽象性密切相关的：简单易懂的系统通常比复杂系统更容易修改。但由于这是一个非常重要的概念，我们将用一个不同的词来指代数据系统层面的敏捷性：可演化性（evolvability）&lt;/p&gt;</content><author><name>Jeremy Yang</name></author><category term="DDIA" /><summary type="html">TOC</summary></entry><entry><title type="html">写在保研之后</title><link href="http://localhost:4000/%E5%86%99%E5%9C%A8%E4%BF%9D%E7%A0%94%E4%B9%8B%E5%90%8E.html" rel="alternate" type="text/html" title="写在保研之后" /><published>2021-10-03T00:00:00+08:00</published><updated>2021-10-03T00:00:00+08:00</updated><id>http://localhost:4000/%E5%86%99%E5%9C%A8%E4%BF%9D%E7%A0%94%E4%B9%8B%E5%90%8E</id><content type="html" xml:base="http://localhost:4000/%E5%86%99%E5%9C%A8%E4%BF%9D%E7%A0%94%E4%B9%8B%E5%90%8E.html">&lt;h3 id=&quot;一次心血来潮的阶段性总结&quot;&gt;一次心血来潮的阶段性总结&lt;/h3&gt;

&lt;p&gt;今天是2021年10月3日，距离保研结束已经过去了好几天，去向也最终尘埃落定了，未来三年半将要继续在哈尔滨进行下一阶段的学习。&lt;/p&gt;

&lt;p&gt;突然发现一晃大学四年的本科生活也已经接近尾声，而我也已然在哈尔滨度过了三个春秋。&lt;/p&gt;

&lt;h3 id=&quot;三年前&quot;&gt;三年前&lt;/h3&gt;

&lt;h4 id=&quot;高中&quot;&gt;高中&lt;/h4&gt;

&lt;p&gt;现在想想高中时候的事已经是很久很久以前了，还记得中考后的我一个很高的成绩（大概是全市五十多名左右的样子）从一所很普通很普通的中学一骑绝尘考入到了全市最好的高中的实验班，那时可能是第一次对自己的能力有了一个大概的预估，大概是第一次觉得自己有可能以后考到一所很不错的985高校。&lt;/p&gt;

&lt;p&gt;那个暑假我很开心，或者可以用意气风发来形容。&lt;/p&gt;

&lt;p&gt;因为有亲戚在南京，加上自己一直对南方都很向往，所以那个暑假特意去了南京待了二十多天，也顺路去了杭州上海。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;印象里南大校园很好看，有法式梧桐，北大楼门口有草坪后面就是紫峰大厦，浙大校园离西湖很近，上交的建筑风格我好喜欢，复旦同济门口就是五角场。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可能就是那时这几所高校在我的心里埋下了一颗小小的种子，觉得自己可能考不上清北，但是这几所学校还是可以努努力奋斗一下的。&lt;/p&gt;

&lt;p&gt;进入高中期间的学习虽然比起初中压力大了不少，不过好在前两年成绩也比较稳定，只是稳定在班级中游罢了。&lt;/p&gt;

&lt;p&gt;记得高三那年冬天因为压力太大曾经每天特别压抑，状态十分不好而且成绩也出现了较大波动，后来春天开学之后刚哥特意把我调到了讲台下面第0排的位置，也非常感谢最后的那个阶段身边的战友高宝还有王妍的陪伴，后来自己的心态还有状态也都逐渐调整了回来。&lt;/p&gt;

&lt;h4 id=&quot;高考&quot;&gt;高考&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;高考的记忆仅剩自己最后也没敢写在作文里的“幸存者偏差”，理综考场上半个小时没做出来的电磁场大题，和648分压线进工大计算机的高考成绩。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;记得当初高考前出分之前的忐忑紧张，以及看到648出现在眼前时，心里对于没有发挥好的一点点失落，以及好在没有考砸了的欣慰，嘴上说着，“嗯这个成绩正常发挥嘛，应该能去武大了”。&lt;/p&gt;

&lt;p&gt;但我知道当时自己心里对于这个成绩是不满意的。&lt;/p&gt;

&lt;p&gt;6月23号那天看到一个个春风满面的认识的或是不认识的同学，我一直有点不舒服，我不知道是什么情绪，可能是羡慕，也可能是眼红，也可能是对自己的懊悔，也可能是对于环境的埋怨，我不知道。&lt;/p&gt;

&lt;p&gt;好在那时已经明确了自己一定要学计算机，不光是看到就业前景，更主要的是高中备考期间看了很多比如陆奇、雷军的成长历程，觉得对比起其他传统工科，计算机这门学科学的都是最新的技术，而且这项技术也在真真切切让人们的生活产生了翻天覆地的变化，如果我能有机会成为无数工程师的一员，为某个项目添砖加瓦，自己也在为改变世界做出一点点力。&lt;/p&gt;

&lt;p&gt;唯一的一个好消息可能是那天发现自己的成绩刚好可以压线进工大计算机。&lt;/p&gt;

&lt;p&gt;还记得那个假期启程去哈尔滨前，爸爸在饭桌上语重心长地和我讲大学一定要好好学习，争取保研保出来，或者也可以继续留在那里深造工作的时候再出来。&lt;/p&gt;

&lt;p&gt;原本心心念念想去南方上大学，最后阴差阳错地来到了祖国的最北方。&lt;/p&gt;

&lt;h3 id=&quot;大一&quot;&gt;大一&lt;/h3&gt;

&lt;p&gt;刚上大学懵懵懂懂，发现自己对于计算机的了解为0，然而身边已经有很多早就打了很多年OI竞赛的同学，自己想要努力弥补自己的不足，只能成天抱着一本C语言教材啃，结果忽视了微积分和线代，一场期中考试就被狠狠地教育了一通，为了不挂科后面就转而闷头学数学，想着万一以后考研这些都是考研要考的，好好学准没问题。嗯对，当时就没怎么想过太多保研的事情，觉得万一保不上就考研考出去。&lt;/p&gt;

&lt;p&gt;结果后来期末数学成绩争气了一把都考到了90+，然后C语言也考到了90+，好像两者都考得还不错，也好像总成绩排名似乎也还凑乎，似乎如果继续保持后续还有希望保研。&lt;/p&gt;

&lt;p&gt;当时突然觉得如果能顺便能将绩点也考高的话可能能多一条路，也不是不可以。然后就阴差阳错地加入了卷学分绩争保研的队伍中来了。&lt;/p&gt;

&lt;h3 id=&quot;大二&quot;&gt;大二&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;大二那年是我最开心的一年。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那年从二校区搬到了一校区，新组了6人寝室，舍友们都很有趣，虽然白天可能各自都不在寝室晚上十点多都陆续回了寝室大家一起开心地唠嗑。&lt;/p&gt;

&lt;p&gt;那年学校开了数据结构、计算机系统这些很难又很重要的计算机基础课程，记得当时学得很吃力，尤其是计算机系统那一门课和《CSAPP》那一本很厚很难啃的教材，每天听着老师飞速念着根本听不大懂的PPT，周末在寝室借着一盏微弱的灯光去一点点地读那本教材，然后一点点去扣那些当时看来很难很难的课程实验，每周仅仅依靠着约定周五周六晚上学习完玩一两个小时来调剂一下。&lt;/p&gt;

&lt;p&gt;整个过程虽然辛苦，但很快乐，当后来期末复习，自己学到多级页表时，学到多级存储换入换出时，我现在仍然记得19年的圣诞节，自己一个人在空荡荡的教室里将CSAPP那本书的某些知识前后连通起来的那一瞬间，突然觉得计算机系统设计特别精妙，那天晚上，路上零下二三十度的低温，除了三三两两过节的同学们，还有一个一脸傻笑着小跑回寝室的男孩子。&lt;/p&gt;

&lt;p&gt;当然最后一整年的成绩也都不错，那时自己也意识到了大二结束之后，读研就业出国便已经成为了三条不怎么相交的路线，也在那时觉得自己还是要走保研这条路，就业的事情等硕士再做打算。&lt;/p&gt;

&lt;p&gt;如今再去想想为什么大二的时候最开心，可能是因为大二不像大一那样懵懂，而是已经了解了一些大学中学习规律和特点，从而能更好地分配自己的精力，大二也不像大三那样突然感觉自己来到了人生的十字路口，突然一下子就要去考虑未来升学、就业等等的一系列未知的事情，去不断衡量每一种选择的利与弊，去不停地考量自己究竟适合哪一条路。大二那年的我心里只有那几门很难但是很有意思的专业课，那几位讲课很棒很棒的老师，那个不算特别高也一点都不低的绩点，每天晚上回宿舍后那几位很合得来的舍友，每周末结束一天的学习后从教学楼小跑回来彻底放松的的那些晚上。&lt;/p&gt;

&lt;h3 id=&quot;2021&quot;&gt;2021&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;2021的关键词是焦虑与迷茫&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2021年的开始便是灰色的，还记得大三刚开始使信心满满地选择了学校里面最难也是最卷的自然语言处理方向，结果经历了半年的摧残，让我成功地对nlp还有深度学习从好奇到乏味甚至到排斥，最终这门课也给了我一个刚上80的成绩对我的态度还以颜色。&lt;/p&gt;

&lt;p&gt;印象中那个寒假很冷很漫长。&lt;/p&gt;

&lt;p&gt;那个寒假应该是自己第一次确定一定一定要争取保研，并且保证万无一失。&lt;/p&gt;

&lt;p&gt;保本校还是外校？继续做NLP方向还是换方向？换方向是该换什么方向？以后是做科研还是去企业？去做算法还是开发？研究生是否要选一个自己感兴趣的方向？以后工作能否找到对口的岗位的工作？&lt;/p&gt;

&lt;p&gt;那个寒假里这些问题也一直萦绕在我的心头。&lt;/p&gt;

&lt;p&gt;那也是我第一次尝试去了解学校里各个实验室的研究方向、去了解互联网公司岗位招聘情况以及学长学姐们的就业的情况。&lt;/p&gt;

&lt;hr data-content=&quot;要不要继续做自然语言处理方向？&quot; /&gt;

&lt;p&gt;首先第一个问题，要不要继续做nlp方向的研究？一来自己实在是对机器学习还有深度学习那一套并不感兴趣，还有大三上半年的学习让我感觉自己并不适合继续做机器学习之类的东西，首先情感上我自己就有点排斥这种类似黑箱一样的技术，炼丹一样的训练过程，我更喜欢传统的CS的技术，比如像计算机系统中的各种优美精巧的算法，整个算法流程的每一步都是可以追溯的，而不是像自己去训练简单的机器学习模型并不知道内部拟合过程而且也无法对实验结果达不到预期做出解释。其次，我想一个真正有竞争力的机器学习工程师应该可以了解各个模型的优缺点，并且能够对每一组数据在特定模型下的不同表现做出合理解释，但是这个需要强大的数学功底，可惜我自己做不到。虽然我机器学习课程考了教学班第一97分，但是我自己知道考得好和学得好是两件交集并不算很大的事情，也知道自己的水平并不足以支撑自己继续进行这方面的研究。&lt;/p&gt;

&lt;p&gt;同时也去了解了关于AI方向求职的信息，才发现之前大家一窝蜂涌入的AI方向也并不像之前媒体渲染的那么强大，也并不是很多人的乌托邦，很多公司的AI算法岗位变得很难进，手握顶会文章可能才是入场券，早已不是很多年前有一些相关经验就可以轻松找到高薪工作的年代了。不过哪怕是现在我依旧认为AI是未来，我也认为这个领域依旧需要很厉害很厉害的人让AI更新迭代，我有幸身边有一些这样子很厉害很厉害的同学，不过我认为那里面并没有我的位置。&lt;/p&gt;

&lt;p&gt;OK，那基本上决定了自己应该是去公司里面去做研发的岗位，我也觉得研发的岗位相对于机器学习或者深度学习算法的岗位要更多，并且研发和算法一样也都是不可或缺的。&lt;/p&gt;

&lt;p&gt;NLP再见，这应该是2021年做的第一个重大决定。&lt;/p&gt;

&lt;hr data-content=&quot;那么保研去什么实验室？&quot; /&gt;

&lt;p&gt;那么下一步保研要去哪里呢？于是便开始厚着脸皮去通过各种方式加上本校研究生学长学姐去依次了解各个实验室的情况。才发现校园里面可能有七八成的实验室都在做AI相关的研究，不管是相关或者不相关的方向现在都和AI相关了。可是这些学生毕业之后都会从事AI相关的工作吗？实验室里面的这些项目能落地吗？什么都要扯上AI是为了好发文章教授可以评职称学生可以毕业吗？我们社会上真的需要这么多做AI的人才吗？或者是像我这样子只会瞎调调参数根本不知道为啥出了结果的废柴真的可以吗？&lt;/p&gt;

&lt;p&gt;后来和几个研究生学长去聊才发现一个普通平凡的工大计算机研究生的路线大概是学校里找一个不上不下的实验室，研一一年要有很多很多课去上，实验室或宽松或紧都不会放实习，大家去实验室的热情也不是很高，由于学制只有两年，研二一开学就面临着秋招找工作，所以大家都会早早地就开始做找工作的准备，然后研二直接秋招找工作，研二下去做一个毕业设计就可以直接毕业入职了。这和我想象中的研究生生活很不一样。&lt;/p&gt;

&lt;p&gt;那我要不要也一样随波逐流找一个nlp实验室然后一边应付课题一边把主要精力投入到自己刷题准备面试找工作上？不，我不想这样。如果能尽可能让研究生的研究方向和未来的就业方向对口就再好不过了。可是如果未来想去做研发的话，这么多搞AI相关的实验室哪个是对口的呢？哪个实验室的研究和未来的工作能够大部分相关呢？&lt;/p&gt;

&lt;hr data-content=&quot;要不要转到软件工程？&quot; /&gt;

&lt;p&gt;一次偶然的巧合之下，突发奇想要不要研究生从计科转到一个软工的实验室，感觉软工那边的实验室可能相对于计科这边的实验室会多一些工程类的项目去做，对于之后找研发类型的工作可能会比较有帮助，于是便想到去学校里面曾将教过我软件构造的王忠杰老师（准确地讲是自己去蹭过课）那里读研，也厚着脸皮加了一些学长学姐，然后感觉老师那里可能比较严格比较push，但是心里想着如果和之后的就业方向一致的话push一些也没什么不好的，吧？&lt;/p&gt;

&lt;p&gt;再后来就是春天开学后直接去找了老师去面谈，老师也非常爽快地想让我加入他的项目组，然后还推了一个学长来带我，那个学长是做微服务方向的，然后也给我推荐了一本书还有安排了一些小任务，老师想让我在春季学期尽快学会这些技术然后一到暑假就开始项目实战。&lt;/p&gt;

&lt;p&gt;当然那个学期一直忙于找实习、做课设、刷绩点，所以就咕咕咕了……&lt;/p&gt;

&lt;hr data-content=&quot;备受打击的春季学期&quot; /&gt;

&lt;p&gt;由于秋季学期考试失利，所以对于保研来说，当时的绩点可能没有那么稳(可能是我自己太过谨慎，事实证明我被打脸，后来今年保研名额增加，然后通过竞赛超过我的同学也没有想象中那么多，最后还是毫无悬念地保研了)所以不得不在大三下依旧去刷学分绩，数据库系统、信息检索这三门课一门比一门硬核，除了数据库系统，其他两门课课上讲得东西根本听不懂并且提不起兴趣，实验也是又多又难，不过好在最后还是熬过来了（尽管做了很大努力最后这学期依旧还是掉分了……）&lt;/p&gt;

&lt;p&gt;互联网上信息的渲染让我第一次意识到了实习可能很重要，而工大由于地理位置因素还有研究生学制的因素，并不能像想象中那样子研究生就可以出去实习找工作，一个学长和我说找实习最佳的时间就是大三结束的时候，于是乎自己就在大三下的时候也去赶忙投了一些简历，阿里，字节，携程，想着尽可能在研究生之前就积攒一些实习经验补足这一块。&lt;/p&gt;

&lt;p&gt;可是一边忙着学校里的课程，一边才开始匆匆准备实习的笔试面试让我一下子倍感压力，也让我头一次感受到了求职的艰辛。&lt;/p&gt;

&lt;p&gt;由于准备匆忙加上自己基础不牢，面试的结果可想而知，我现在依然记得自己去面试字节的时候感觉自己就像是去搞笑的，问自己的计网项目稍微一深挖就不知道回答什么了，然后好不容易问到了一个我准备过的面试题“java里面的hashmap具体是怎么实现的？”“由链表和红黑树构成，当数据量大于8的时候自动由链表变成红黑树”心里想着终于能答上来一道，后面那个面试官“你来解释解释为什么用红黑树不用AVL树？”我“不知道……可能是查询更快吧”（然而当时我心里其实根本早就忘记了AVL树是什么），最后面试官很无奈说那我们做一道算法题吧，然后自己憋了半天最后写出了一个跑不出正确结果的代码，面试官和我面面相觑，最后我只能抱歉地说浪费了您的时间。&lt;/p&gt;

&lt;p&gt;那时突然想到了之前另一个学长和我说的一句话“那些能找到实习的同学哪怕不实习也能秋招找到工作”&lt;/p&gt;

&lt;p&gt;再加上自己之前也咨询过一个研二学姐，那个学姐虽然也去了微软亚洲研究院实习，但是由于那里并不能转正，然后再找其他其他公司时候面试去问实习也是去问项目细节去看实习的含金量，所以就算是实验室的项目或者是实习的项目都是可以的，只要是真正有东西的项目企业不会不重视的。&lt;/p&gt;

&lt;p&gt;而且也听说了很多实习做着杂活并没有转正结果浪费了暑假宝贵的准备秋招的时间的例子。&lt;/p&gt;

&lt;p&gt;所以思想观念也从一开始的必须实习变成了后面辩证性地看待实习这件事情。&lt;/p&gt;

&lt;p&gt;说起找实习经历，让我最感谢的是阿里巴巴国际站一面时候遇到的一个面试官大哥。&lt;/p&gt;

&lt;p&gt;那天和那个面试官聊了好久好久，面试官也没有用刁钻的面试题来为难我，更多的是去问我项目中的思想还有自己的想法，后来在最后向面试官提问的环节我向他寻求一些对于在校期间技术方面的建议，很令我惊讶的是，这位面试官并没有像网上那些贩卖焦虑的营销号或者是刚刚入职的学长学姐一样说多刷算法题，多刷面经或者是多找实习，而是推心置腹地和我说，他在互联网行业这么多年（电话面试听声音感觉前辈已经三四十岁了）感觉在校期间最重要的还是比如数据结构、操作系统、计算机网络这些最最基础的三板斧，不管是哪一波浪潮来了，不管是最一开始PC上面的互联网，还是后面移动端或者是现在的AI浪潮，最底层的那些东西都是不变的，所以在学校里面打下牢固的基础才是最最重要的，然后他说他面试校招生的时候感觉学生会有一个误区，就是比如去问计算机网络的时候倒是很多很多问题都能对答如流，问操作系统的时候也是可以对答如流，但是很多问题都是割裂的没有一个成体系的感觉，当在这个行业待久了就会知道这些计算机底层的知识其实是可以融会贯通的，当你能将这些知识融会贯通起来的时候就是你真正有了扎实的计算机基础的时候。&lt;/p&gt;

&lt;p&gt;真的真的很感谢很感谢那位愿意陪我电话面试唠一两个小时嗑的阿里面试官。&lt;/p&gt;

&lt;p&gt;经过开学一个多月的彷徨，也咨询了形形色色的人，发现了一个有趣的现象，当去问正在找工作或者刚入职的学长学姐，他们会说一定一定要多找实习或者多刷题多背面经，问企业里比较资深的工程师的时候，他们会说一定要在学校里面打好扎实的计算机基础，问学校里面的教授或者导师，他们会说研究生阶段最重要的培养自己的研究能力，而这项能力也是以后工作中所必须具备的。&lt;/p&gt;

&lt;p&gt;我想，可能是因为每个人的观点都是基于自身视角所给出的，每个人所经历的事情每个人所在的立场不一样自然会给出不同的结论。&lt;/p&gt;

&lt;p&gt;但我逐渐认识到，学校的title大不大并没有想象中那么重要，学历只是敲门砖罢了，工大的title足以叩开绝大多数互联网公司的绝大多数部门的大门了，后面表现如何，就真的真的只看自己的个人能力了。&lt;/p&gt;

&lt;p&gt;而就是那些面试让我深刻意识到自己的能力是有多差，正如好友汪泽昊后来和我说的“不少工大计院的同学从一入学就开始做梦，直到某一瞬间梦醒了，可能是保研前，也可能是找实习的时候，也可能永远没醒过来，对于我来说是在今年保研前”，我想对于我自己来说，可能是春天找实习的时候，梦突然醒了，让自己真正意识到自己最应该做的是提升自己的能力，将自己之前的坑都补全，而不是为自己能够保研而沾沾自喜。&lt;/p&gt;

&lt;p&gt;这几年也有幸见过一些学校里真正厉害的大佬们，有的本科就早早进实验室开始做科研发出顶会文章，有的在各种竞赛中斩获国家级奖项，有的自己凭着兴趣去自己做很多小项目，有的绩点遥遥领先每年国奖拿到手软保送top2或华五，才慢慢意识到同一个学校里面同学和同学之间的差距远远大于学校与学校之间的差距，而自己只是一个代码能力差的一比勉勉强强将绩点刷高捞了个保研的混子罢了。&lt;/p&gt;

&lt;p&gt;不过哪怕是最终终于卷出来了，对于学校的培养方案课程设置还有评分机制还是有很多很多要吐槽的地方，自己虽然在大二的时候就已经意识到了自己既然选择绩点优先的路的时候就要承受现在这样的结果（当时想着等到保研一结束的大四还有研究生阶段就要以能力为优先导向去学习，现在看来好在自己的去向也基本符合自己的预期），但还是在前三年的学习历程中做了很多妥协，为了绩点做了很多我认为没有太多意义的事情，比如一个简简单单的实验报告为了写的好看专门去学latex，然后花一两天时间专门去写报告去排版（对就是之前我diss的那门机器学习课程，当然最后成绩确实是很好看），这些做法其实一直在我心里是嗤之以鼻的，但是为了绩点确确实实自己在大二大三这两年去将时间花在了这些事情上了。&lt;/p&gt;

&lt;p&gt;作为一个绩点制度和以保研为导向的单一评价体系下的既得利益者反过来去说这个制度的种种不好，未免也挺滑稽的。&lt;/p&gt;

&lt;p&gt;好在自己梦醒了，也有自知之明，也即将开启新的以提升自身能力为导向的阶段。&lt;/p&gt;

&lt;p&gt;于是此时再去看保研保到什么地方，我便不像之前那样唯title论，而是觉得最适合自己的才是最好的。&lt;/p&gt;

&lt;hr data-content=&quot;似乎有机会圆梦南大&quot; /&gt;

&lt;p&gt;依旧还是大三下那个学期，有一次浏览南京大学软件学院的网站的时候，看到里面的实验室还有老师的简介，找到了一个研究方向和未来工作十分贴合的老师，基本上都是工程开发的项目，比如什么基于微服务的应用开发，部署及维护，熟练掌握docker，消息队列等技术……当看到这个的时候一下子就心动了，这不就是和以后后台开发之类的工作十分吻合的项目吗？而且了解到南软专硕只有两年而且必须去企业实习，我一下子就觉得如果为了硕士毕业就直接就业的话这个简直是完美的选择。&lt;/p&gt;

&lt;p&gt;后来联系到了老师，而且非常幸运的是老师对于我也十分认可，在4月份就参加了一次对方实验室的面试，并且面试结果也还不错，所以从整个4月到7月都是一边努力准备期末考试保证能拿到保研资格，一边等着这边期末考试结束之后着手准备南软的夏令营，心里觉得这肯定是稳了，而且终于终于有机会圆梦南大，所以一直一直心里都很欣喜激动。&lt;/p&gt;

&lt;p&gt;我心里之前想着既然南大软院的bar可能没有南大cs和ai那么高，觉得以自己的水平应该争取争取能优秀吧，结果发现自己还是太天真了，由于线上夏令营很多学生都采取了海投的策略，导致像我这种rank不算特别特别突出然后又没有什么科研的同学根本没有机会入营，更别提优营了。&lt;/p&gt;

&lt;p&gt;当那天得知这个消息的时候自己有些惊讶，也有些难过，并且决定立马也改变策略，暑假认真准备专业课，然后冲预推免到九月的时候也要海投。可是后来才发现自己又天真了，很多学校夏令营招够了优秀营员以及足够长的waiting list之后便不再进行预推免，比如上交。&lt;/p&gt;

&lt;hr data-content=&quot;充满了焦虑、彷徨、迷茫、消沉的一个夏天&quot; /&gt;

&lt;p&gt;这个暑假其实很消沉。&lt;/p&gt;

&lt;p&gt;保外前途渺茫，看着很多成绩+科研+竞赛样样全能的大佬们早就已经手握好多offer，自己却夏令营变成夏零营，预推免能否入营还依旧是个未知数。&lt;/p&gt;

&lt;p&gt;保内早已错失良机，学校里比较好的实验室比较好的老师已经被立志留本校的同学早早抢去了名额，剩下的实验室还有导师自己其实都不太愿意去。&lt;/p&gt;

&lt;p&gt;此时陷入了一个进退两难的局面。&lt;/p&gt;

&lt;p&gt;暑假里在自己身上出现了一种非常奇怪的状态，仿佛在某一个瞬间，自己突然对很多东西一下子都提不起兴趣了，不想学习，不想玩游戏，不想出去玩，不想社交不想参加饭局。暑假整个人处于一个能量很低气压很低的状态。&lt;/p&gt;

&lt;p&gt;我也一直在想，外校的title，南大的情节，软件学院，专硕，java开发，这些到底值不值得我去花这么多精力和时间去争取？自己研究生阶段到底想要的是什么？&lt;/p&gt;

&lt;p&gt;后来一次偶然的机会在网上了解到了TiDB这个分布式数据库产品还有PingCAP这家很cool的公司，看到数据库，分布式，高并发，存储引擎这些字眼的时候我发现自己逐渐变得兴奋了起来。&lt;/p&gt;

&lt;p&gt;依稀记得这种感觉之前只在我的身上出现过两次，一次是19年冬天学计算机系统看到段页式存储管理，一次是21年春天数据库系统课程上面当老师讲到缓冲池替换算法，并且自己联想到操作系统课程中相应的替换算法的时候，这可能就是之前阿里那位前辈所说的，融会贯通的一点点苗头了吧。&lt;/p&gt;

&lt;p&gt;要不，研究生去做数据库吧？一个大胆的念头在心里产生。&lt;/p&gt;

&lt;p&gt;后来就开始在网上搜集各种相关的前景，比如了解到了蚂蚁金服的OceanBase团队还有华为的Gauss团队都是技术水平极高的团队，也都在做着很cool的产品，虽然也有人说这个行业门槛高，想要做好很难很难，不过在这样的团队工作可以极大提升自己的技术水平，在公司里面这个团队可能短期内并没有去做业务或者做类似王者这种手游挣钱，但是我自己觉得找工作并不能只盯着眼前的起薪，而更应该去看自己到公司的团队里面的成长空间，毕竟同一家公司里面组和组之间的差距可能比公司和公司的差距更大，而我更想去那种技术为导向的组而不是kpi为导向的业务的组。&lt;/p&gt;

&lt;p&gt;本校恰好自己数据库系统的邹兆年老师就是在做数据库系统方面的研究，老师水平也很高，风评也很好，于是便萌发了自己想要跟着这个老师读研的想法，可惜由于已经太晚，老师那个实验室几乎已经招满了人，然后自己几个朋友之前去找这个老师也被婉拒了。&lt;/p&gt;

&lt;p&gt;在假期的尾巴上，和爸爸妈妈沟通了我的想法，他们也表示十分支持我。&lt;/p&gt;

&lt;p&gt;大概9月份开学之后，保研优先级便是&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;优先级&lt;/th&gt;
      &lt;th&gt;课题组&lt;/th&gt;
      &lt;th&gt;对应的研究生生活&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;最高&lt;/td&gt;
      &lt;td&gt;本校数据库组&lt;/td&gt;
      &lt;td&gt;在这个领域继续进行深耕，研究生要研究源码，要尝试自己做改进，认真做课题，然后毕业奔着几个大厂的数据库团队求职&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;其次&lt;/td&gt;
      &lt;td&gt;南软软件工程组&lt;/td&gt;
      &lt;td&gt;由于是软件工程，所以拓展了技术广度，前端后端等等技术要争取样样精通，之后帮着导师做项目，自己刷实习，找后端前端这种业务开发类型的工作&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;最次&lt;/td&gt;
      &lt;td&gt;本校放羊组&lt;/td&gt;
      &lt;td&gt;导师和实验室不怎么管，实验室研究的方向和找工作的方向也毫无关系，然后自己去研究自己感兴趣的领域，自己去刷题刷面经准备秋招找工作&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这次走之前爸爸跟我说，虽然爸爸不懂你们的专业，但是研究生一定一定要选一个自己喜欢的行业啊，如果不喜欢的话会很苦恼的。&lt;/p&gt;

&lt;hr data-content=&quot;柳暗花明又一村&quot; /&gt;

&lt;p&gt;开学之后便着手开始准备面试，投预推免，然后也一边准备去找本校的邹老师。&lt;/p&gt;

&lt;p&gt;九月的第一个好消息是，把消息发给邹老师的时候老师约了我面谈，面谈的时候老师第一句话就是，你怎么和成绩单上面的照片不一样了（那个照片是18年入学拍的丑死了……）,然后又说老师记得我上课时候很认真努力，最后成绩也很不错，老师非常耐心地给我介绍了他的研究方向，最后也很爽快地答应了我让我入组。&lt;/p&gt;

&lt;p&gt;后来陆陆续续收到浙大初审没过，哈深初审没过的拒信，不过那已经关系不大了。&lt;/p&gt;

&lt;p&gt;九月的第二个好消息是突然收到了南大初审通过准备面试的邮件，一时不知道是高兴还是什么情绪，终于之前的梦校如今和我只差一步之遥了，机会就摆在面前还是要试一下，先把选择权握在自己手上。&lt;/p&gt;

&lt;p&gt;于是便又开始纠结工大or南大？算了准备面试先。&lt;/p&gt;

&lt;p&gt;另一个转折点是在南软面试的时候，当我辛辛苦苦准备了计算机专业课基础知识的时候，发现那里只是考了八股文，自己准备了好久的DBMS中的缓冲池实现这个项目，面试的老师根本不care，还中途打断问我究竟做没做过什么项目，可能在那个软工的老师心里，只有做一个什么app或者上线一个什么什么系统才能称得上是一个项目吧。&lt;/p&gt;

&lt;p&gt;面试体验极差，同时也让我明白了CS到SE其实已经算是跨专业，CS这边的东西至少那个老师看不上，而那边的项目在我眼里也没有数据库的项目更感兴趣。同时之前对于那个学院的各种担忧，比如一些网上看到的黑料，还有一些南大软院那里的朋友都和我说快逃等等诸如此类情感的在一个瞬间爆发了。&lt;/p&gt;

&lt;p&gt;虽然几乎已经确定想要留在哈尔滨了，但还是多多少少有点不甘心也在最后还是有点纠结，后来第二天晚上和任一通了一个多小时的电话，也和家里人打了好久电话，最终终于定下来要留在这里了，在这里继续在自己喜欢的方向进行深耕。&lt;/p&gt;

&lt;p&gt;再后来，在填系统前一天收到了南大软院的offer，然后自己很坚定地放弃了，也给那边的老师发了很长的一段道歉信，鸽掉那边的老师也真的挺不好意思的（因为那个老师人真的超好真的真的特别不好意思）。&lt;/p&gt;

&lt;p&gt;后来28号填系统报志愿，一个非常幸运的事情是，之前本校实验室只给我分配了一个专硕的名额，后来某个占着学硕名额的buaa的同学最后鸽掉了，我顺位最终拿到了0812学硕名额，也算是一个那天很幸运很开心的一件事情了。&lt;/p&gt;

&lt;p&gt;在后来就是看着朋友圈和空间里面大家在晒去向和录取结果，清华的，北大的，清深的，上交的，浙大的，原本以为自己继续留在这里会不甘心，以为自己会像高考后那样很羡慕很眼红，但是惊奇的发现自己好像并没有，心里很踏实很平静。&lt;/p&gt;

&lt;p&gt;这里有自己很喜欢的方向，也有自己很喜欢的导师，实验室也是学校里面的头牌实验室之一，这里还有自己熟悉的环境，也有好多本科时期很好的朋友。&lt;/p&gt;

&lt;p&gt;记得之前白鹭在朋友圈发过的一篇小作文里面说的一句“很难比较，每天坚持做三道解析几何，和经历失眠和焦虑后做出一次勇敢的选择，哪一个努力了更多”&lt;/p&gt;

&lt;p&gt;可能经历了2021一整年的失眠和焦虑，最后终于知道了自己想要的是什么，也在这个过程中成长了许多。&lt;/p&gt;

&lt;h3 id=&quot;下个阶段&quot;&gt;下个阶段&lt;/h3&gt;

&lt;p&gt;保研结束之后，进了组，分了工位，然后邹老师还安排了一位特别热心负责技术水平也高的研二学长带我去完成一些基础可以上手的任务。&lt;/p&gt;

&lt;p&gt;（插一句很有意思的事情，其实在填系统前一天晚上我很焦虑就给导师打了电话，其中向导师寻求大四还有研究生阶段的规划路线的建议的时候，老师给我的规划和我设想的理想中的研究生生活几乎一致，老师还推荐了一本书给我让我这学期学一下，很巧的是当我一搜发现，那本书之前就已经进了我当当网的购物车！）&lt;/p&gt;

&lt;p&gt;下个阶段还要继续加油努力啊！还有好多好多东西要去学，还有好多好多坑还没有填。&lt;/p&gt;

&lt;h3 id=&quot;写在最后&quot;&gt;写在最后&lt;/h3&gt;

&lt;p&gt;2021这一年对于我来说应该是非常非常特殊的一年，十分感谢一直在我身后支持我的爸爸妈妈，也十分感谢一直在我身边以各种方式默默陪着我的朋友们，有的在我非常迷茫的时候被我一通电话拉出来一打就是好久，有的朋友哪怕自己也在考研也愿意听我叨叨自己的焦虑并且也一点都没有觉得我是在凡尔赛，有的朋友总是在食堂吃完饭之后一起在操场遛弯聊天，也有的被我拉到学校旁的小清吧喝酒，也还有一些其他专业的朋友虽然不是太懂计算机专业里面的知识，但是也以其他的方式给予我源源不断的能量，比如有的朋友在我最低沉的那段日子里时不时地就拉我出来散心，拉我出来享受美食，也有的朋友关心我的去向和想法，也有的在那段日子里和我一同分享读书的心得和喜悦。在我最最煎熬的日子里（可能有时候我不愿意将太多负面情绪传递出来所以可能平时并不明显），你们的每一点关心和共情，或者是在我最低沉的时候给我传递来的一点点快乐和一点点能量，我都会记得，真的真的十分感谢。&lt;/p&gt;</content><author><name>Jeremy Yang</name></author><category term="view" /><summary type="html">一次心血来潮的阶段性总结</summary></entry></feed>